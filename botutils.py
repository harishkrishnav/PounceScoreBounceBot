import discord 
from pdf2image import convert_from_path
import os
import pickle

async def deleteAllMessages(bot, guildId, whitelistChannels):
    """
    @param bot the instance of the running bot in use by the calling function
    @param guildId the Guild ID in use by the calling function
    @param whitelistChannels the list of whitelisted channels from which messages 
        are not deleted
    """
    guild =  bot.get_guild(int(guildId))
    for channel in guild.text_channels:
        if channel.name not in whitelistChannels:
            while(True):
                deleted = await channel.purge(limit=1000)
                if not len(deleted):
                    break

def getAuthorized(ctx,  message_start, message_end, *authorizedRoles):
    """
    @param ctx 
    """
    author = ctx.message.author
    authorRoles = [str(role).lower() for role in author.roles[1:]]
    for role in authorizedRoles:
        if role in authorRoles:
            return True, ''
    response = message_start+', or '.join(authorizedRoles)+message_end
    return False, response

def getAuthorizedServer(bot, guildId, ctx):
    guild = bot.get_guild(int(guildId))
    if ctx.message.guild != guild:
        print("Ignoring message sent from other server")
        return False
    else:
        return True

def getAuthorAndName(ctx):
    """
    Takes the context variable from the calling function and returns the author
    object and the author display name, formatted.
    @param ctx the context passed to the calling function
    @return author the author object
    @return authorName the display name of the author
    """
    author = ctx.message.author
    authorName = str(author.display_name).split("#")[0]
    return author, authorName

def getCommonChannels(bot, guildId, whitelistChannels):
    """
    @param bot the instance of the running bot in use by the calling function
    @param guildId the Guild ID in use by the calling function
    @param whitelistChannels the channels that are not on the commonChannels or on
            the teamChannels
    @return commonChannels a dictionary mapping channel names to channel IDs
    """
    guild = bot.get_guild(int(guildId))
    commonChannels = {}
    for channel in guild.text_channels:
        cn = channel.name
        if not (cn.startswith('team') and cn.endswith('-chat')):
            if cn not in whitelistChannels:
                commonChannels[cn] = bot.get_channel(channel.id)
    return commonChannels


def getTeamChannels(bot, guildId, numberOfTeams):
    """
    @param bot the instance of the running bot in use by the calling function
    @param guildId the Guild ID in use by the calling function
    @param numberOfTeams the limit on the number of teams for the quiz
    @return teamChannels a dictionary mapping team names to channel IDs
    """
    guild = bot.get_guild(int(guildId))
    teamChannels = {}
    for channel in guild.text_channels:
        cn = channel.name
        if cn.startswith('team') and cn.endswith('-chat'):
            teamNo = int(cn.split('team')[1].split('-chat')[0])
            if teamNo <= numberOfTeams:
                teamChannels[cn.replace('-chat','')] = bot.get_channel(channel.id)
    return teamChannels

    
def getTeamDistribution(bot, guildId, scores, names=False):
    """
    @param bot the instance of the running bot in use by the calling function
    @param guildId the Guild ID in use by the calling function
    @param scores the scores dictionary that also tracks active teams
    @return teamDistribution Dictionary of teams and their members
    """
    guild =  bot.get_guild(int(guildId))
    teamDistribution = {}
    for team in scores:
        teamDistribution[team] = []
    for member in guild.members:
        for role in member.roles:
            if role.name.startswith("team"):
                try:
                    assert role.name in teamDistribution
                    if names:
                        teamDistribution[role.name].append(member.display_name)
                    else:
                        teamDistribution[role.name].append(member)
                except:
                    print("Please check that teamnames match roles (no \
spaces). Someone might have a role of a team \
that isn't in this quiz.")
    return teamDistribution

def getTeamMembers(teamDistribution, team):
    """
    @param teamDistribution team distribution generated by getTeamDistribution
    @param team the team we are trying to get members of
    @return list of string display names of team members
    """
    memberList = []
    for member in teamDistribution[team]:
        memberList.append(member.display_name.split("#")[0])
    return memberList

def getTeam(author):
    """
    Takes the author object and returns the team the author is a member of
    @param author the author object
    """
    tmp = []
    for role in author.roles[1:]:
        if role.name.startswith('team'):
            tmp.append(str(role.name.lower()))
    team = ', '.join(tmp)
    return team

async def unassignTeams(bot, guildId, ctx):
    """
    @param bot the instance of the running bot in use by the calling function
    @param guildId the Guild ID in use by the calling function
    """
    guild =  bot.get_guild(int(guildId))
    for member in guild.members:
        for role in member.roles:
            if role.name.startswith("team"):
                try:
                    await member.remove_roles(role)
                    response = 'Removing {} from {}.\
                            '.format(str(member.display_name),str(role.name))
                    await ctx.send(str(response))
                except:
                    print("Did not remove",member,"from",role,"because of \
permissions. Make the bot an admin and run this again.")



def deleteFiles(directoryPath, *extensions):
    for extension in extensions:
        filelist = [f for f in os.listdir(directoryPath) if f.endswith(extension)]
        print("deleting", filelist)
        for f in filelist:
            os.remove(os.path.join(directoryPath, f))

def convertToImages(presentationDirPath, presentationFileName):
    deleteFiles(presentationDirPath, '.jpg')
    presentationFilePath = os.path.join(presentationDirPath, presentationFileName)

    imagelist = []

    pages = convert_from_path(presentationFilePath, 100)
    for index, page in enumerate(pages):
        filename = str(index)+'.jpg'
        page.save(os.path.join(presentationDirPath, filename), 'JPEG')
        imagelist.append(filename)
        print("generating page, ", filename)

    return imagelist


async def updateSlides(ctx, filename, commonChannels, teamChannels, bounceChannel, pounceChannel, scoreChannel):
    url = ""
    with open(filename, 'rb') as f:
        picture = discord.File(f)
        channel = commonChannels[bounceChannel]
        await channel.send(file=picture)
    message = await commonChannels[bounceChannel].history(limit=1).flatten()
    if len(message) > 0:
        message = message[0]
        if len(message.attachments) > 0: 
            print(message.attachments[0].url)
            url = message.attachments[0].url
    channel = commonChannels[scoreChannel]
    await channel.send(url)
    for team in teamChannels:
        await teamChannels[team].send(url)
    channel = commonChannels[pounceChannel]
    await channel.send(url)

    #with open(filename, 'rb') as f:
    #    picture = discord.File(f)
    #    channel = commonChannels[scoreChannel]
    #    await channel.send(file=picture)
    #for team in teamChannels:
    #    with open(filename, 'rb') as f:
    #        picture = discord.File(f)
    #        await teamChannels[team].send(file=picture)
    #with open(filename, 'rb') as f:
    #    picture = discord.File(f)
    #    channel = commonChannels[pounceChannel]
    #    await channel.send(file=picture)
    response = "All teams have received the slide"
    await ctx.message.channel.send(response)


def saveSlideState(saveTo, state):
    with open(saveTo, 'wb') as f:
        pickle.dump(state, f)

def recoverSlideState(savePath):
    with open(savePath, 'rb') as f:
        state = pickle.load(f)
    return state

